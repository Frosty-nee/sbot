#!/usr/bin/env python3

import json
import sys
import time
import traceback
import zlib
import _thread

import requests
import websocket

import code_eval
import config
import eve
import utils

def main():
	bot = Bot({
		'calc': utils.calc,
		'roll': utils.roll,
		'time': utils.timezones,

		'pc': eve.price_check,
		'price': eve.price_check,
		'jumps': eve.jumps,
		'ly': eve.lightyears,

		'js': code_eval.nodejs,
		'ruby': code_eval.irb,
		'python3': code_eval.python3,
	})
	bot.connect()
	bot.run_forever()

class Bot:
	def __init__(self, commands):
		self.ws = None
		self.rs = requests.Session()
		self.rs.headers['Authorization'] = 'Bot ' + config.bot.token
		self.rs.headers['User-Agent'] = 'DiscordBot (https://github.com/raylu/sbot 0.0'
		self.heartbeat_thread = None
		self.user_id = None
		self.seq = None

		self.handlers = {
			OP.HELLO: self.handle_hello,
			OP.DISPATCH: self.handle_dispatch,
		}
		self.events = {
			'READY': self.handle_ready,
			'MESSAGE_CREATE': self.handle_message_create,
		}
		self.commands = commands

	def connect(self):
		if config.state.gateway_url is None:
			data = self.get('/gateway/bot')
			config.state.gateway_url = data['url']
			config.state.save()

		url = config.state.gateway_url + '?v=5&encoding=json'
		self.ws = websocket.create_connection(url)

	def run_forever(self):
		while True:
			raw_data = self.ws.recv()
			# one might think that after sending "compress": true, we can expect to only receive
			# compressed data. one would be underestimating discord's incompetence
			if isinstance(raw_data, bytes):
				raw_data = zlib.decompress(raw_data).decode('utf-8')
			if not raw_data:
				break
			if config.bot.debug:
				print('<-', raw_data)
			data = json.loads(raw_data)
			self.seq = data['s']
			handler = self.handlers.get(data['op'])
			if handler:
				try:
					handler(data['t'], data['d'])
				except:
					tb = traceback.format_exc()
					if config.bot.err_channel:
						try:
							self.send_message(config.bot.err_channel, '```\n%s\n```' % tb[:2000])
						except Exception as e:
							print('error sending to err_channel: %r' % e, file=sys.stderr)
					print(tb, file=sys.stderr)

	def get(self, path):
		response = self.rs.get('https://discordapp.com/api' + path)
		response.raise_for_status()
		return response.json()

	def post(self, path, data):
		if config.bot.debug:
			print('=>', path, data)
		response = self.rs.post('https://discordapp.com/api' + path, json=data)
		response.raise_for_status()
		return response.json()

	def send(self, op, d):
		raw_data = json.dumps({'op': op, 'd': d})
		if config.bot.debug:
			print('->', raw_data)
		self.ws.send(raw_data)

	def send_message(self, channel_id, text):
		self.post('/channels/%s/messages' % channel_id, {
			'content': text,
		})

	def handle_hello(self, _, d):
		print('connected to', d['_trace'])
		self.heartbeat_thread = _thread.start_new_thread(self.heartbeat_loop, (d['heartbeat_interval'],))
		self.send(OP.IDENTIFY, {
			'token': config.bot.token,
			'properties': {
				'$browser': 'github.com/raylu/sbot',
				'$device': 'github.com/raylu/sbot',
			},
			'compress': True,
			'large_threshold': 50,
			'shard': [0, 1]
		})

	def handle_dispatch(self, event, d):
		handler = self.events.get(event)
		if handler:
			handler(d)

	def handle_ready(self, d):
		print('connected as', d['user']['username'])
		self.user_id = d['user']['id']

	def handle_message_create(self, d):
		print('%s> %s' % (d['author']['username'], d['content']))

		content = d['content']
		if len(content) < 20 or not content.startswith('<@'):
			return
		for mention in d['mentions']:
			if mention['id'] == self.user_id:
				break
		else: # we are not mentioned
			return

		message = content[content.find('>') + 2:]
		split = message.split(' ', 1)
		handler = self.commands.get(split[0])
		if handler:
			arg = ''
			if len(split) == 2:
				arg = split[1]
			cmd = CommandEvent(d['channel_id'], d['author'], arg, self)
			handler(cmd)

	def heartbeat_loop(self, interval_ms):
		interval_s = interval_ms / 1000
		while True:
			time.sleep(interval_s)
			self.send(OP.HEARTBEAT, self.seq)

class CommandEvent:
	def __init__(self, channel_id, sender, args, bot):
		self.channel_id = channel_id
		# sender = {
		#     'username': 'raylu',
		#     'id': '109405765848088576',
		#     'discriminator': '8396',
		#     'avatar': '464d73d2ca17733636282ab58b8cc3f5',
		# }
		self.sender = sender
		self.args = args
		self.bot = bot

	def reply(self, message):
		self.bot.send_message(self.channel_id, message)

class OP:
	DISPATCH              = 0
	HEARTBEAT             = 1
	IDENTIFY              = 2
	STATUS_UPDATE         = 3
	VOICE_STATE_UPDATE    = 4
	VOICE_SERVER_PING     = 5
	RESUME                = 6
	RECONNECT             = 7
	REQUEST_GUILD_MEMBERS = 8
	INVALID_SESSION       = 9
	HELLO                 = 10
	HEARTBEAT_ACK         = 11

if __name__ == '__main__':
	main()
