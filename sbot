#!/usr/bin/env python3

import json
import zlib

import requests
import websocket

import config

def main():
	bot = Bot()
	bot.connect()
	bot.run_forever()

class Bot:
	def __init__(self):
		self.ws = None
		self.rs = requests.Session()
		self.rs.headers['Authorization'] = 'Bot ' + config.bot.token
		self.rs.headers['User-Agent'] = 'DiscordBot (https://github.com/raylu/sbot 0.0'
		self.heartbeat_interval = None # in ms
		self.user_id = None

		self.handlers = {
			OP.HELLO: self.handle_hello,
			OP.DISPATCH: self.handle_dispatch,
		}
		self.events = {
			'READY': self.handle_ready,
			'MESSAGE_CREATE': self.handle_message_create,
		}

	def connect(self):
		if config.state.gateway_url is None:
			data = self.get('/gateway/bot')
			config.state.gateway_url = data['url']
			config.state.save()

		url = config.state.gateway_url + '?v=5&encoding=json'
		self.ws = websocket.create_connection(url)

	def run_forever(self):
		while True:
			raw_data = self.ws.recv()
			# one might think that after sending "compress": true, we can expect to only receive
			# compressed data. one would be underestimating discord's incompetence
			if isinstance(raw_data, bytes):
				raw_data = zlib.decompress(raw_data).decode('utf-8')
			if not raw_data:
				break
			if config.bot.debug:
				print('<-', raw_data)
			data = json.loads(raw_data)
			handler = self.handlers.get(data['op'])
			if handler:
				handler(data['t'], data['d'])

	def get(self, path):
		response = self.rs.get('https://discordapp.com/api' + path)
		response.raise_for_status()
		return response.json()

	def post(self, path, data):
		if config.bot.debug:
			print('=>', path, data)
		response = self.rs.post('https://discordapp.com/api' + path, json=data)
		response.raise_for_status()
		return response.json()

	def send(self, op, d):
		raw_data = json.dumps({'op': op, 'd': d})
		if config.bot.debug:
			print('->', raw_data)
		self.ws.send(raw_data)

	def send_message(self, channel_id, text):
		self.post('/channels/%s/messages' % channel_id, {
			'content': text,
		})

	def handle_hello(self, _, d):
		print('connected to', d['_trace'])
		self.heartbeat_interval = d['heartbeat_interval']
		self.send(OP.IDENTIFY, {
			'token': config.bot.token,
			'properties': {
				'$browser': 'github.com/raylu/sbot',
				'$device': 'github.com/raylu/sbot',
			},
			'compress': True,
			'large_threshold': 50,
			'shard': [0, 1]
		})

	def handle_dispatch(self, event, d):
		handler = self.events.get(event)
		if handler:
			handler(d)

	def handle_ready(self, d):
		print('connected as', d['user']['username'])
		self.user_id = d['user']['id']

	def handle_message_create(self, d):
		print('%s> %s' % (d['author']['username'], d['content']))
		if d['content'] == 'test':
			self.send_message(d['channel_id'], 'ahoy!')

class OP:
	DISPATCH              = 0
	HEARTBEAT             = 1
	IDENTIFY              = 2
	STATUS_UPDATE         = 3
	VOICE_STATE_UPDATE    = 4
	VOICE_SERVER_PING     = 5
	RESUME                = 6
	RECONNECT             = 7
	REQUEST_GUILD_MEMBERS = 8
	INVALID_SESSION       = 9
	HELLO                 = 10
	HEARTBEAT_ACK         = 11

if __name__ == '__main__':
	main()
